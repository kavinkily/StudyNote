# Swift Apprentice 读书笔记

标签（空格分隔）： 读书笔记

---


## Chapters 1
CPU 从 RAM 里拉取数值，然后通过 math Unit 存储到另一个 registers。
每个程序都是由成千上万条指令组成的，你写的代码会通过编译器转化为 CPU 能读懂的指令。
进制如何算：假如是2进制，那么从右往左乘以2.
16进制用 a 到 f 补全。a 表示10。16进制的每个数都可以用固定的二进制表示。32位所能存储的最大数值为4294967295，用16进制表示就是ffffffff。
## Chapters 2
元组可以由任意类型的值组成。
可以通过下标来取元组的对应下标值。
也可以通过对元组的每个数值用参数修饰,然后可以通过元组.参数取出对应的值。
可以通过（x, y）来获取多个元组的值。
## Chapters 3
可以在小数上取模。
1 << 2 等于1乘以2的2次方。
## Chapters 4
(img)这两个字符串在别的语言里也许是不相等的，但是在 swift 是相等的。count 都是4.
`string.uppercaseString`可以全变大写。
`string.lowercaseString`可以全变小写。
## Chapters 6
参数都是常数。想要改变参数，需要添加关键字 inout。
## Chapters 8
当闭包为最后个参数时，可以使用尾随闭包。
filter 函数可以判断数组元素是否符合条件。
数组插入元素复杂度：在第一个或者最后插入，复杂度为O(1)，也就是常亮时间 C，当在中间插入是，复杂度约等于 Cn。在最后插入时，如果没有空间了，编译器会复制整个数组再插入，这样负责度为O(N)。
数组移除元素负责度和上面相同。
## Chapter 11
- 在字典中使用下标取 value，当 key 值不存在时，返回 nil。
- 使用`updateValue`如果 key 不存在，会生成一个新的字典，使用下标同理。
- Swift 每个基本类型都有哈希值，字典中处理，插入，删除，搜索元素消耗的性能都是O(1)。
## Chapter 12
- 集合的 value 是唯一的。
- 通过`union`可以将两个集合结合起来，`intersect`可以返回个集合中相同的元素，`subtract`可以将参数中没出现的元素返回，`exclusiveOr`返回其中之一集合没有的元素。
- 集合使用场景是，你需要确定这个集合中是否含有某个元素，通过`contains`。
## Chapter 13
- 如果实例化一个结构体为 let，那么就算结构体里面的属性为 var，你也不能修改这个属性的值。
- 结构体会自动生成实例化方法，如果你想自己定义一个实例化方法，你可以使用`init`来初始化，这样做会使系统自动生成的初始化方法失效。
- 初始化结构体必须实例化每个存储属性除了可选值。
## Chapter 15
- `final`防止继承。
- 子类初始化方法也要初始化父类的属性。
- 只有当最顶层的类的属性都被实例化了，self 才能被调用,也就是在 super 调用以后。
- `required`告诉子类必须实现和重写这个方法。
- `convenience`可以让初始化方法直接调用别的初始化方法，但是有以下几点要注意
    - 必须调用的当前类的其他初始化方法
    - 必须在最后调用指定的初始化方法
- 值类型存储在堆里，引用类型存储在栈。
## Chapter 16
- Swift 不同于 C，他的原始值不仅限于 Int,可以自己分配任意基本类型，并且设置了第一个 value 的原始值后，可以自动补齐后面 value 的值。
- 如果在枚举初始化时设置原始值`Month(rawValue: 5)`，返回的值是可选的，必须判断是否为 nil 或者使用可选绑定。
- 枚举下的任何case 不能同时拥有原始值和原始类型。
## Chapter 17
- 只有类和结构体才有存储属性。
- 存储属性必须设置为变量且声明类型。
- 使用`pow(width, 2)`可以计算第一个参数的次方。
- 使用`sqrt(_:)`可以计算平方根。
- 使用`round(_:)`可以四舍五入。
- 等号左边是 set，右边是 get。
- 创建单例
```swift
class Manager {
    static let shareManager = Manager()
    private init() {}
}
```
- 用 class 创建单例比 struct 好，因为使用结构体单例不能改变结构体里属性的值，class 可以，因为 class 只有地址在内存里是不变的。
- `didSet` 和 `willSet` 只在当属性完全初始化后设置新值才起效。
- 懒加载属性其实是一个存储属性，且必须设置为变量。
- 可以使用`{ }()`来给一个存储属性添加计算操作。
## Chapter 18
- 结构体里的方法不加`mutating`前缀不能修改结构体里的属性。
- 因为结构体是值类型，当在方法中改变属性的值，初始化的值和复制过的值不相同。

